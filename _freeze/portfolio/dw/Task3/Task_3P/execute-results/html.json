{
  "hash": "0791290b8864e6e81ae17110888ebd2f",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Working with numpy Matrices (Multidimensional Data)'\njupyter: python3\n---\n\n::: {#bfef7f4c .cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport scipy\n```\n:::\n\n\n## Introduction\nThis task requires working with `numpy` matrices and Python to conduct a data analysis exercise involving body measurement data for males and females. The multidimensional body measurement data is loaded into a `numpy` matrix from a text file. `Numpy` vector operations are used to calculate the body mass index, append it to the matrix, and standardise the male data. Histogram and box plots were created using the Matplitlib library, and some descriptive statistics were calculated. A scatterplot matrix and matrices for Pearson's correlation and Spearman's rho were produced to allow visual and quantitative inspection of the associations between each variable. \n\n\n## Data input\nExcerpts giving the body measurements of adult males and females from the National Health and Nutrition Examination Survey ([NHANES](https://wwwn.cdc.gov/nchs/nhanes/search/datapage.aspx) dataset) have been used for this analysis. The data was downloaded from a [GitHub repository](https://github.com/gagolews/teaching-data/tree/master/marek) as two CSV files:\n\n  * nhanes_adult_male_bmx_2020.csv\n  * nhanes_adult_female_bmx_2020.csv\n\nThese files are loaded into two `numpy` 2-dimensional arrays using the `numpy.loadtxt` function. The first 19 lines of the files contain header information and were ignored during the loading.\n\n::: {#9f47950d .cell execution_count=2}\n``` {.python .cell-code}\n# Load the male data\nmale = np.loadtxt(\"nhanes_adult_male_bmx_2020.csv\", skiprows=19, delimiter=\",\")\n\n# load the female data\nfemale = np.loadtxt(\"nhanes_adult_female_bmx_2020.csv\", skiprows=19, delimiter=\",\")\n\n# Names for columns\ndata_column_labels = np.array([\"weight\", \"height\", \"upper arm len.\", \"upper leg len.\",\n                               \"arm circ.\", \"hip circ.\", \"waist circ.\", r\"BMI\", ])\n```\n:::\n\n\n### Helper function to calculate body mass index\nNow that we have the body measurement data loaded from the CSV files, we can calculate the BMI for each observation in the datasets. This is done in the helper function `calculate_bmi`. Using slicing, we select the columns representing the weight and height measurements and pass them to the function. Take care that the units of the data match those required in the function. The function uses `numpy` vector operations to calculate the BMI and return it as a `numpy` vector. This is conducted for both the male and female data arrays.\n\n::: {#144a0767 .cell execution_count=3}\n``` {.python .cell-code}\ndef calculate_bmi(weight, height):\n    \"\"\"\n    Calculates the BMI for a person given the weight (kg) and height (m) using the traditional\n    method.\n\n    The formula is BMI = weight/height^2\n\n    :param weight: A numpy vector of the weight of the person in kilograms.\n    :param height: A numpy vector of the height of the person in meters.\n    :return: A numpy vector containing the traditional BMI.\n    \"\"\"\n    # Handle any input type errors\n    # Check if weight is an integer or float\n\n    # We only need to check one value in vector as numpy requires all data to be the same type\n    if not (np.issubdtype(weight[0].dtype, np.floating) or np.issubdtype(weight[0].dtype, np.integer)):\n        raise Exception(f\"Weight is not a number, the type provided is {type(weight[0])}\")\n\n    # Check height can be converted to a float    \n    if not (np.issubdtype(height[0].dtype, np.floating) or np.issubdtype(height[0].dtype, np.integer)):\n        raise Exception(f\"Height is not a number, the type provided is {type(height)}\")\n\n    # At this point, both input variables are known to be numbers. Now check they have the\n    # appropriate range.\n    if np.min(weight) <= 0:\n        raise Exception(f\"The persons weight must be greater than zero. \"\n                        f\"At least one zero or lower value detected.\")\n    if np.min(height) <= 0:\n        raise Exception(f\"The persons height must be greater than zero.\"\n                        f\" At least one zero or lower value detected.\")\n\n    # Calculate the BMI\n    persons_bmi = weight / height ** 2\n\n    return persons_bmi\n```\n:::\n\n\n::: {#582ae260 .cell execution_count=4}\n``` {.python .cell-code}\n# Calculate the BMI using the calculate_bmi function\n# Column 0 is the weight, and column 1 is the height, making sure we convert height from cm to m\nbmi_male = calculate_bmi(male[:, 0], male[:, 1] / 100)\nbmi_female = calculate_bmi(female[:, 0], female[:, 1] / 100)\n```\n:::\n\n\nNow, we have `numpy` vectors containing the BMI values for the males and females. We can add these as a column to the original dataset using the `numpy.column_stack` function. In this case, I have stored the result in a new array for each gender. However, you could choose to overwrite the original array if you wish.\n\n::: {#7cffbedb .cell execution_count=5}\n``` {.python .cell-code}\n# Add the BMI as a column to the raw data and store the result in a new 2-dimensional array.\nmale_data = np.column_stack((male, bmi_male))\nfemale_data = np.column_stack((female, bmi_female))\n```\n:::\n\n\n## Histogram Plots\nHistogram plots for the female and male BMIs are produced using `Matpliblib.pyplot.hist` with 20 bins. The plots are created as subplots in a single figure with the same x-axis limits to allow visual inspection and comparison of the distribution of each dataset (see below). The plots have been coloured to help distinguish between them.\n\n::: {#a0feda4e .cell execution_count=6}\n``` {.python .cell-code}\nnum_bins = 20\n\n# Create figure with specified size\nhist_fig = plt.figure(figsize=(11, 7))\n\n# Plot female \nax1 = plt.subplot(2, 1, 1)  # 2 rows, 1 column, 1st subplot\nax1.hist(female_data[:, 7], num_bins, edgecolor=\"hotpink\", color=\"deeppink\")\nax1.set_title(f\"Female BMIs (n={female_data.shape[0]})\")\n\n# Plot male\nax2 = plt.subplot(212, sharex=ax1)  # 2 rows, 1 column, 2nd subplot\nax2.hist(male_data[:, 7], num_bins, edgecolor=\"lightskyblue\", color=\"dodgerblue\")\nax2.set_title(f\"Male BMIs (n={male_data.shape[0]})\")\n\n# Set the x limit for both plots\nplt.xlim(10, 70)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Task_3P_files/figure-html/cell-7-output-1.png){width=881 height=579}\n:::\n:::\n\n\n## Box Plots\nBox plots for each dataset have been produced to compare distributions from a descriptive statics viewpoint visually. The left side of the box is the first quartile, the right side is the third quartile, and the white line inside the box is the median. The box length represents the inter-quartile range (IQR) and represents 50\\% of the data. The whiskers are placed at 1.5*IQR above and below the third and first quartiles. Values outside the whiskers are termed outliers.\n\nThe `Matplotlib.pyplot.boxplot` function was used to create the plot. The figure size was adjusted to reduce the vertical white space and increase its width. Again, the box plots have been coloured to help distinguish each dataset.\n\n::: {#b15b1f4e .cell execution_count=7}\n``` {.python .cell-code}\nplt.figure(figsize=(11, 4))\nlabels = [\"Male\", \"Female\"]\ncolours = [\"dodgerblue\", \"deeppink\"]\nbplot = plt.boxplot([male_data[:, 7], female_data[:, 7]], vert=False, patch_artist=True,\n                    tick_labels=labels, medianprops=dict(color=\"white\", linewidth=1.5))\n\n# Fill with colors\nfor patch, colour in zip(bplot[\"boxes\"], colours):\n    patch.set_facecolor(colour)\n\n# Set the x-axis limits\nplt.xlim(10, 70)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Task_3P_files/figure-html/cell-8-output-1.png){width=903 height=337}\n:::\n:::\n\n\n## Descriptive Statistics for the BMI data\nThe following descriptive statistics are calculated using the helper function `stats_describe` function that returns a dictionary:\n\n - Arithmetic mean\n - Median\n - Minimum\n - Maximum\n - Standard deviation\n - Inter-quartile range (IQR)\n - Skewness\n - Number of observations in the data\n\n::: {#84faedbb .cell execution_count=8}\n``` {.python .cell-code}\ndef stats_describe(a):\n    \"\"\"\n    Compute several descriptive statistics of the passed array. This function borrows ideas from\n    the scipy.stats.describe function.\n\n    :param a: Input 1-d data array.\n    \n    :return: A dictionary containing the descriptive statistics for the input data,\n        a_mean: Arithmetic mean of `a`.\n        a_median: Arithmetic mean of `a`.\n        a_min: Minimum value of `a`.\n        a_max: Maximum value of `a`.\n        a_std: Standard deviation of `a` using ddof=1\n        a_iqr: Inter-quartile range value of `a`.\n        a_skew: Skewness value of `a`.\n        n: Number of observations in the data\n    \"\"\"\n\n    if a.size == 0:\n        raise ValueError(\"The input must not be empty.\")\n\n    n = a.shape[0]\n    a_min = np.min(a, axis=0)\n    a_max = np.max(a, axis=0)\n    a_mean = np.mean(a, axis=0)\n    a_median = np.median(a, axis=0)\n    a_std = np.std(a, axis=0, ddof=1)\n    a_iqr = scipy.stats.iqr(a, axis=0)\n    a_skew = scipy.stats.skew(a, axis=0, bias=True)\n\n    return {\"mean\": a_mean, \"median\": a_median, \"min\": a_min, \"max\": a_max, \"std\": a_std,\n            \"IQR\": a_iqr, \"skew\": a_skew, \"num. obs.\": n}\n```\n:::\n\n\nCalculate the descriptive statistics for both male and female body mass indices.\n\n::: {#349e15ff .cell execution_count=9}\n``` {.python .cell-code}\nmale_stats = stats_describe(male_data[:, 7])\nfemale_stats = stats_describe(female_data[:, 7])\n```\n:::\n\n\nPrint the descriptive statics in a table-like format.\n\n::: {#ca3a6b5f .cell execution_count=10}\n``` {.python .cell-code}\n# Spacing to help with formatting of the printing\npadding = 10\n\n# Print the header\nprint(\"Descriptive Statistics for BMI data\")\nprint(f\"##                female      male\")\n\n# Iterate over dictionary keys, printing the information for each gender for each key. \nfor key in female_stats.keys():\n    # \n    if key == \"mean\":\n        print(f\"## BMI {key:<{padding}}{round(female_stats[key], 2):7.2f}   \"\n              f\"{round(male_stats[key], 2):7.2f}\")\n    elif key == \"num. obs.\":\n        print(f\"##     {key:<{padding}}{round(female_stats[key], 0):7g}   \"\n              f\"{round(male_stats[key], 0):7g}\")\n    else:\n        print(f\"##     {key:<{padding}}{round(female_stats[key], 2):7.2f}   \"\n              f\"{round(male_stats[key], 2):7.2f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDescriptive Statistics for BMI data\n##                female      male\n## BMI mean        30.10     29.14\n##     median      28.89     28.27\n##     min         14.20     14.91\n##     max         67.04     66.50\n##     std          7.76      6.31\n##     IQR         10.01      7.73\n##     skew         0.92      0.97\n##     num. obs.    4221      4081\n```\n:::\n:::\n\n\nFrom the histogram plot, the distribution of BMI for females is unimodal and skewed to the right (higher BMI values). For males, the distribution is unimodal and skewed to the right. The box plots show the median BMI (white line in the boxes) for females is higher than for males. Comparing the box length shows that the female BMI distribution has a larger spread than the males. This is also observed visually in the histograms but is easier to identify in the box plots. Both distributions show many outliers on the right side of the distribution and none on the left. The conclusions from the visual inspection of the plots can be verified by inspection of the descriptive statistics.\n\n\n## Standardising the data\nWe can standardise the data by subtracting the mean from each element and dividing it by the standard deviation. Here we use the vectorised functionality of `numpy` to do the standardisation for each measurement (column) in a single command. We constrain the operations to the columns by setting `axis=0` in the `mean` and `std` operations.\n\nHere we are standardising only the male data.\n\n::: {#9d0e05b6 .cell execution_count=11}\n``` {.python .cell-code}\nzmale = (male_data - np.mean(male_data, axis=0)) / np.std(male_data, axis=0)\n```\n:::\n\n\nThe `pair_plot` function plots a matrix of scatter plots of several variables against each other. These are useful for visually identifying associations between variables.\n\n::: {#507f04e4 .cell execution_count=12}\n``` {.python .cell-code}\ndef pair_plot(a, data_labels, ax_labels, alpha=0.3):\n    \"\"\"\n    Draws a scatter plot matrix, given a data matrix, column data_labels, and column units.\n\n    This function is modified from section 7.4.3 of Gagolewski M. (2025).\n\n    Reference:\n    Gagolewski M. (2025), Minimalist Data Wrangling with Python, Melbourne,\n        DOI: 10.5281/zenodo.6451068, ISBN: 978-0-6455719-1-2,\n        URL: https://datawranglingpy.gagolewski.com/.\n\n    :param a: data matrix,\n    :param data_labels: list of column names\n    :param ax_labels: list of data_labels for axes\n    :param alpha: transparency\n    \"\"\"\n    # Get the number of columns\n    k = a.shape[1]\n\n    # The number of columns in X must match the number of data_labels provided\n    assert k == len(data_labels)\n\n    # Create the figure and axes for subplots\n    fig, axes = plt.subplots(nrows=k, ncols=k, sharex=\"col\", sharey=\"row\", figsize=(10, 10))\n    for i in range(k):\n        for j in range(k):\n            ax = axes[i, j]\n            if i == j:  # diagonal\n                ax.text(0.5, 0.5, data_labels[i], transform=ax.transAxes,\n                        ha=\"center\", va=\"center\", size=\"medium\")\n            else:\n                ax.scatter(a[:, j], a[:, i], s=10, color=\"dodgerblue\", edgecolor=\"lightskyblue\",\n                           alpha=alpha, zorder=2)\n                ax.grid(zorder=1, alpha=0.5)\n\n            # Print the column axes labels only on the left side and bottom of the pair-plot figure\n            if j == 0:\n                ax.set_ylabel(ax_labels[i], fontsize=10)\n            if i == len(data_labels) - 1:\n                ax.set_xlabel(ax_labels[j], fontsize=10)\n    fig.tight_layout()\n```\n:::\n\n\nCreate the pair plot for the standardised male data.\n\n::: {#b55d036b .cell execution_count=13}\n``` {.python .cell-code}\n# Plot the height, weight, waist circumference, hip circumference, and BMI\ncolumns_to_plot = [1, 0, 6, 5, 7]\n\n# Labels for axes\naxes_labels = np.array([\"z\"] * 8)\n\n# Create the plot using the `pair_plot` function\npair_plot(zmale[:, columns_to_plot], data_column_labels[columns_to_plot],\n          axes_labels[columns_to_plot], alpha=0.8)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Task_3P_files/figure-html/cell-14-output-1.png){width=937 height=950}\n:::\n:::\n\n\n## Pearson Correlation and Spearman's Rho\nThe Pearson correlation measures the strength of the linear association between two quantitative variables (De Veaux et al., 2020 p. 200). The correlation values will be between -1 and 1. Positive values indicate a positive association, e.g., when one variable increases, the other also increases. Negative values indicate a negative association, e.g., when one variable increases, the other decreases.  Spearman's Rho correlation uses the Pearson correlation on the rank of the values of two variables (De Veaux et al., 2020 p. 206). It also has values between -1 and 1. Spearman's rho uses the rank of the variables to measure the consistency of the trend (monotonic relationship) between the two variables. Pearson's correlation is sensitive to strong outliers, whereas Spearman's rho is not.\n\n::: {#31904671 .cell execution_count=14}\n``` {.python .cell-code}\ndef corrheatmap(a, data_labels, lbl_set_dict):\n    \"\"\"\n    Draws a correlation heat map, given a matrix of numbers and a list of column names.\n\n    This function is modified from section 9.1.2 of Gagolewski M. (2025).\n\n    Reference:\n    Gagolewski M. (2025), Minimalist Data Wrangling with Python, Melbourne,\n        DOI: 10.5281/zenodo.6451068, ISBN: 978-0-6455719-1-2,\n        URL: https://datawranglingpy.gagolewski.com/.\n\n    :param a: - matrix of numbers for all variable pairs.\n    :param data_labels: list of column names\n    :param lbl_set_dict: a dictionary of settings indicating whether data_labels should be turned\n    on or off for different aspects of the plots\n    \"\"\"\n    # Get number of rows in the input array \n    k = a.shape[0]\n\n    # Number of rows must equal the number of columns and the number of data_labels provided.\n    assert a.shape[0] == a.shape[1] and a.shape[0] == len(data_labels)\n\n    # plot the heat map using a custom colour palette\n    # (correlations are in [-1, 1])\n    plt.imshow(a, cmap=plt.colormaps.get_cmap(\"RdBu\"), vmin=-1, vmax=1)\n\n    # Add text data_labels\n    for i in range(k):\n        for j in range(k):\n            plt.text(i, j, f\"{a[i, j]:.2f}\", ha=\"center\", va=\"center\",\n                     color=\"black\" if np.abs(a[i, j]) < 0.5 else \"white\", size=\"medium\", weight=550)\n\n    plt.xticks(np.arange(k), labels=data_labels, rotation=30)\n    plt.tick_params(axis=\"x\", which=\"both\",\n                    labelbottom=lbl_set_dict[\"labelbottom\"], labeltop=lbl_set_dict[\"labeltop\"],\n                    bottom=lbl_set_dict[\"bottom\"], top=lbl_set_dict[\"top\"])\n\n    plt.yticks(np.arange(k), labels=data_labels)\n    plt.tick_params(axis=\"y\", which=\"both\",\n                    labelleft=lbl_set_dict[\"labelleft\"], labelright=lbl_set_dict[\"labelright\"],\n                    left=lbl_set_dict[\"left\"], right=lbl_set_dict[\"right\"])\n\n    # Turn off grid lines\n    plt.grid(False)\n```\n:::\n\n\nGenerate a correlation heat map for Pearson's correlation and Spearman's rho for the standardised male data.\n\n::: {#81520e45 .cell execution_count=15}\n``` {.python .cell-code}\nplt.figure(figsize=(11, 11))\nR = np.corrcoef(zmale, rowvar=False)\n\nax1 = plt.subplot(1, 2, 1)  # 1 rows, 2 column, 1st subplot\nlabel_settings = {\"labelbottom\": True, \"labeltop\": False, \"bottom\": True, \"top\": False,\n                  \"labelleft\": True, \"labelright\": False, \"left\": True, \"right\": False\n}\ncorrheatmap(R[np.ix_(columns_to_plot, columns_to_plot)], data_column_labels[columns_to_plot],\n            label_settings)\nax1.set_title(\"Pearsons's r\")\n\nax2 = plt.subplot(1, 2, 2)  # 1 rows, 2 column, 2nd subplot\n\nlabel_settings = {\"labelbottom\": True, \"labeltop\": False, \"bottom\": True, \"top\": False,\n                  \"labelleft\": False, \"labelright\": True, \"left\": False, \"right\": True\n}\n\nrho = scipy.stats.spearmanr(zmale)[0]\ncorrheatmap(rho[np.ix_(columns_to_plot, columns_to_plot)], data_column_labels[columns_to_plot],\n            label_settings)\nax2.set_title(r\"Spearman's $\\rho$\")\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](Task_3P_files/figure-html/cell-16-output-1.png){width=990 height=466}\n:::\n:::\n\n\nFrom the pair plot and the heat maps above, the following can be said regarding the associations between the height, weight, waist circumference, hip circumference and BMI variables.\n\n * BMI has a strong positive linear association (r > 0.8) with weight, waist circumference and hip circumference and a very weak (0 < r < 0.1) positive linear association with height.\n * Hip circumference has a strong positive linear association with weight and waist circumference and a weak ( 0.1 < r < 0.5) positive linear association with height.\n * Waist circumference has a strong positive linear association with weight, hip circumference, and BMI and a weak positive linear association with height.\n * Weight has a weak positive linear association with height.\n * There are a couple of reasons why the weight, waist circumference and hip circumference have a strong association with BMI, whereas height has a weak association.\n     - The formula for BMI is weight divided by height squared. This creates a stronger relationship with weight over height.\n     - Fat distribution is more likely associated with waist and hip circumferences than height. Since weight increases with fat percentage, there is going to be a strong association between weight, waist and hip circumference. This is shown with the correlation coefficients between weight and these variables being greater than 0.9. Since there is a strong association between BMI and weight, any other quantity that has a strong association with weight will also have a strong association with BMI.\n * The Spearman's rho values are similar to the Pearson correlation values for both the strong and weak associations.\n     - For the strong associations this suggests the association between the variables is primarily linear.\n     - For the weak and below associations, this suggests that neither a linear nor monotonic association is present between theariables.s.\n   \n\n## Summary\nThis Jupyter Notebook demonstrates the use of `numpy` matrices, vectors, and functions to analyse body measurement data quantitatively using descriptive statistics and visually using histograms, box plots, and scatter plot matrices.\n\nPossible extensions to the data analysis include:\n- Add a standard model curve to the histogram plots to visually compare with the standard model.\n- Consider doing linear regression on the data to see if a predictive model for BMI can be produced from the body measurements.\n\n## References\n\n[1] R. D. De Veaux, P. F. Velleman, and D. E. Bock, Stats: Data and Models. Hoboken, NJ: Pearson, 2020. ‌\n\n",
    "supporting": [
      "Task_3P_files"
    ],
    "filters": [],
    "includes": {}
  }
}