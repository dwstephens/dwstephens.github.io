{
  "hash": "2799f1cc73d4d460f3b3e026f038f260",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: 'Pandas/Polars versus SQL'\njupyter:\n  jupytext:\n    formats: ipynb,py:percent\n  kernelspec:\n    display_name: Python 3 (ipykernel)\n    language: python\n    name: python3\n---\n\n::: {#34ec126b .cell execution_count=1}\n``` {.python .cell-code}\nimport os\nimport sqlite3\nimport pandas as pd\nimport numpy as np\nimport polars as pl\nimport tempfile\nimport timeit\n```\n:::\n\n\n## Introduction\nThis task requires working with `pandas` to write code that produces equivalent output to various SQL queries. The [nycflights13](https://cran.r-project.org/web/packages/nycflights13/index.html) dataset is used for this exercise. The dataset gives information about all 336,776 flights that departed from three New York airports in 2013 to destinations in the United States, Puerto Rico, and the American Virgin Islands. \nAdditionally, equivalent queries were also written using the polars library, and the execution time for the pandas and polars libraries was calculated and compared.\n\n\n### Database connection\nAn SQLite3 database file is created on the local disk for use during these tasks. \n\n::: {#66f5906e .cell execution_count=2}\n``` {.python .cell-code}\n#\n# Create a database file in a temporary location\ndbfile = os.path.join(tempfile.mkdtemp(), \"nycflights.db\")\nprint(dbfile)\n\n# Connect to database\nconn = sqlite3.connect(dbfile)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nC:\\Users\\darrin\\AppData\\Local\\Temp\\tmpll_hbexh\\nycflights.db\n```\n:::\n:::\n\n\n\n### Load data files and export to database \nCompressed csv files containing data about New York City flights, airlines, airports, planes and weather are loaded from the local disk into `pandas` dataframes. The `pandas` dataframes are exported as tables to the SQLite3 database file. \n\nPolars dataframes (having _pl suffix on the name) are also created from the pandas dataframes. These will be used for testing the `polars` library in the tasks below.\n\n::: {#327276ce .cell execution_count=3}\n``` {.python .cell-code}\nflights = pd.read_csv(\"nycflights13_flights.csv.gz\", comment=\"#\")\nflights_pl = pl.from_pandas(flights)\n```\n:::\n\n\n\n::: {#12f8bbbf .cell execution_count=4}\n``` {.python .cell-code}\nairlines = pd.read_csv(\"nycflights13_airlines.csv.gz\", comment=\"#\")\nairlines_pl = pl.from_pandas(airlines)\n```\n:::\n\n\n\n::: {#327d6ae2 .cell execution_count=5}\n``` {.python .cell-code}\nairports = pd.read_csv(\"nycflights13_airports.csv.gz\", comment=\"#\")\nairports_pl = pl.from_pandas(airports)\n```\n:::\n\n\n\n::: {#0418aaa4 .cell execution_count=6}\n``` {.python .cell-code}\nplanes = pd.read_csv(\"nycflights13_planes.csv.gz\", comment=\"#\")\nplanes_pl = pl.from_pandas(planes)\n```\n:::\n\n\n\n::: {#fcd9cfc8 .cell execution_count=7}\n``` {.python .cell-code}\nweather = pd.read_csv(\"nycflights13_weather.csv.gz\", comment=\"#\")\nweather_pl = pl.from_pandas(weather)\n```\n:::\n\n\n\n::: {#b12d14f9 .cell execution_count=8}\n``` {.python .cell-code}\n# Export dataframes to the database\nflights.to_sql(\"flights\", conn, index=False)\nairlines.to_sql(\"airlines\", conn, index=False)\nairports.to_sql(\"Badges\", conn, index=False)\nplanes.to_sql(\"planes\", conn, index=False)\nweather.to_sql(\"weather\", conn, index=False)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\n26130\n```\n:::\n:::\n\n\n## SQL queries and equivalent Pandas and Polars queries\nThis section contains 17 different SQL queries and the pandas and polars code to give equivalent output.\n\n::: {#33a1e8e6 .cell execution_count=9}\n``` {.python .cell-code}\n# Helper function to testing equality between dataframes\ndef test_dataframe_equality(df1, df2, name=\"SQL\"):\n    \"\"\"\n    Function to test if two dataframes are equal.\n\n    :param df1: First pandas dataframe.\n    :param df2: Second pandas dataframe.\n    :param name: Name of the method used to generate the first pandas dataframe.\n    :return: None.\n    \"\"\"\n    try:\n        pd.testing.assert_frame_equal(df1, df2)\n        print(f\"Outcome of comparison: {name} and Pandas results are equal\")\n    except AssertionError as e:\n        print(f\"Outcome of comparison: {name} and Pandas results are not equal: {e}\")\n\n```\n:::\n\n\n::: {#9bfd66b3 .cell execution_count=10}\n``` {.python .cell-code}\n# Helper function to print execution times\ndef print_execution_data(pd_dur, pl_dur):\n    \"\"\"\n    Function to print a table comparing Pandas to Polars execution time.\n    \n    :param pd_dur: pandas execution duration.\n    :param pl_dur: polars execution duration.\n    :return: None.\n    \"\"\"\n    print()\n    print(\"Metric                Pandas    Polars\")\n    print(f\"Execution time [s]:  {pd_dur:.4g}  {pl_dur:.4g}\")\n    print(f\"Relative to Pandas:  {1}           {pl_dur/pd_dur:.3g}\")\n```\n:::\n\n\n### Task 1\nThis SQL query selects the unique engines in the engines column from the planes table.\n\nMy pandas command:\n - In the planes dataframe, drop the duplicate rows by considering the engines column. Then select only the engines column and reset the index.\n\n::: {#e3de7068 .cell execution_count=11}\n``` {.python .cell-code}\n# SQL result\ntask1_sql = pd.read_sql_query(\"\"\"SELECT DISTINCT engine FROM planes\"\"\", conn)\n\n# Pandas result with timing\nt1_st = timeit.default_timer()\n\ntask1_my = planes.drop_duplicates(subset=\"engine\")[[\"engine\"]].reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task1_my.head(), \"\\n\")\n\nt1_et = timeit.default_timer()\nt1_dur = t1_et - t1_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task1_sql, task1_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n          engine\n0      Turbo-fan\n1      Turbo-jet\n2  Reciprocating\n3        4 Cycle\n4    Turbo-shaft \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#a06bcb8e .cell execution_count=12}\n``` {.python .cell-code}\n# Polars result with timing\nt1_st_pl = timeit.default_timer()\n\ntask1_pl = planes_pl.unique(subset=[\"engine\"]).select([\"engine\"])\n\nt1_et_pl = timeit.default_timer()\nt1_dur_pl = t1_et_pl - t1_st_pl\n\n# Checking the Pandas result == Polars result. We need to covert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task1_my.sort_values(by=[\"engine\"]).reset_index(drop=True),\n                        task1_pl.to_pandas().sort_values(by=[\"engine\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t1_dur, t1_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.002907  0.003202\nRelative to Pandas:  1           1.1\n```\n:::\n:::\n\n\n\n### Task 2\nThis SQL query selects rows with the unique combination of type and engines from the planes table.\n\nMy pandas command:\n - In the planes dataframe, drop the duplicate rows by considering the type and engine columns. Then select only the type and engine columns and reset the index.\n\n::: {#65b371d9 .cell execution_count=13}\n``` {.python .cell-code}\n# SQL result\ntask2_sql = pd.read_sql_query(\"\"\"SELECT DISTINCT type, engine FROM planes\"\"\", conn)\n\n# Pandas result with timing\nt2_st = timeit.default_timer()\n\ntask2_my = planes.drop_duplicates(subset=[\"type\", \"engine\"])[[\"type\", \"engine\"]].reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task2_my.head(), \"\\n\")\n\nt2_et = timeit.default_timer()\nt2_dur = t2_et - t2_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task2_sql, task2_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n                       type         engine\n0   Fixed wing multi engine      Turbo-fan\n1   Fixed wing multi engine      Turbo-jet\n2  Fixed wing single engine  Reciprocating\n3   Fixed wing multi engine  Reciprocating\n4  Fixed wing single engine        4 Cycle \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#d1a85ca1 .cell execution_count=14}\n``` {.python .cell-code}\n# Polars result with timing\nt2_st_pl = timeit.default_timer()\n\ntask2_pl = planes_pl.unique(subset=[\"type\", \"engine\"]).select([\"type\", \"engine\"])\n\nt2_et_pl = timeit.default_timer()\nt2_dur_pl = t2_et_pl - t2_st_pl\n\n# Checking the Pandas result == Polars result. We need to covert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task2_my.sort_values(by=[\"type\", \"engine\"]).reset_index(drop=True),\n                        task2_pl.to_pandas().sort_values(by=[\"type\", \"engine\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t2_dur, t2_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001832  0.001769\nRelative to Pandas:  1           0.965\n```\n:::\n:::\n\n\n\n### Task 3\nThis SQL query counts how many planes there are in the planes table for each engine type and returns the count along with the engine type\n       \nMy pandas command:\n - In the planes dataframe, group the rows by the engine column and get the size of each group. Then reset the index and rename its column to COUNT(*). Select the columns in order to match the SQL query result.\n\n::: {#b0fbe913 .cell execution_count=15}\n``` {.python .cell-code}\n# SQL result\ntask3_sql = pd.read_sql_query(\"\"\"SELECT COUNT(*), engine FROM planes GROUP BY engine\"\"\", conn)\n\n# Pandas result with timing\nt3_st = timeit.default_timer()\n\ntask3_my = planes.groupby(\"engine\").size().reset_index(name=\"COUNT(*)\")[[\"COUNT(*)\", \"engine\"]]\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task3_my.head(), \"\\n\")\n\nt3_et = timeit.default_timer()\nt3_dur = t3_et - t3_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task3_sql, task3_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n   COUNT(*)         engine\n0         2        4 Cycle\n1        28  Reciprocating\n2      2750      Turbo-fan\n3       535      Turbo-jet\n4         2     Turbo-prop \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#9d2bb415 .cell execution_count=16}\n``` {.python .cell-code}\n# Polars result with timing\nt3_st_pl = timeit.default_timer()\n\ntask3_pl = planes_pl.group_by(\"engine\").agg(pl.len().alias(\"COUNT(*)\")).select([\"COUNT(*)\", \"engine\"])\n\nt3_et_pl = timeit.default_timer()\nt3_dur_pl = t3_et_pl - t3_st_pl\n\n# Polars returns uint32 for len(), so we need to cast to allow comparison with pandas.\ntask3_pl = task3_pl.with_columns(pl.col(\"COUNT(*)\").cast(pl.Int64))\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task3_my.sort_values(by=[\"engine\"]).reset_index(drop=True),\n                        task3_pl.to_pandas().sort_values(by=[\"engine\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t3_dur, t3_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001778  0.00439\nRelative to Pandas:  1           2.47\n```\n:::\n:::\n\n\n\n### Task 4\n\nThis SQL query counts the number of planes in the planes table for each engine and plane type group and returns the count along with the engine type and plane type.\n\nMy pandas command\n - In the planes dataframe, group the rows by the engine and type columns and get the size of each group. Then reset the index and rename its column to COUNT(*). Then select the columns in order to match the SQL query result.\n\n::: {#7272cf3e .cell execution_count=17}\n``` {.python .cell-code}\n# SQL result\ntask4_sql = pd.read_sql_query(\"\"\"SELECT COUNT(*), engine, type FROM planes GROUP BY engine, type\"\"\", conn)\n\n# Pandas result with timing\nt4_st = timeit.default_timer()\n\ntask4_my = planes.groupby([\"engine\", \"type\"]).size().reset_index(name=\"COUNT(*)\")[[\"COUNT(*)\", \"engine\", \"type\"]]\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task4_my.head(), \"\\n\")\n\nt4_et = timeit.default_timer()\nt4_dur = t4_et - t4_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task4_sql, task4_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n   COUNT(*)         engine                      type\n0         2        4 Cycle  Fixed wing single engine\n1         5  Reciprocating   Fixed wing multi engine\n2        23  Reciprocating  Fixed wing single engine\n3      2750      Turbo-fan   Fixed wing multi engine\n4       535      Turbo-jet   Fixed wing multi engine \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#09e86b3e .cell execution_count=18}\n``` {.python .cell-code}\n# Polars result with timing\nt4_st_pl = timeit.default_timer()\n\ntask4_pl = planes_pl.group_by([\"engine\", \"type\"]).agg(pl.len().alias(\"COUNT(*)\")).select([\"COUNT(*)\", \"engine\", \"type\"])\n\nt4_et_pl = timeit.default_timer()\nt4_dur_pl = t4_et_pl - t4_st_pl\n\n# Polars returns uint32 for len(), so we need to cast to allow comparison with pandas.\ntask4_pl = task4_pl.with_columns(pl.col(\"COUNT(*)\").cast(pl.Int64))\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task4_my.sort_values(by=[\"engine\", \"type\"]).reset_index(drop=True),\n                        task4_pl.to_pandas().sort_values(by=[\"engine\", \"type\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t4_dur, t4_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.002324  0.002474\nRelative to Pandas:  1           1.06\n```\n:::\n:::\n\n\n\n### Task 5\n\nThis SQL query gives the minimum, average and maximum years for each unique combination of engine and manufacturer.\n \nMy pandas command:\n - For the planes dataframe, group the rows by engine and manufacturer. Select the year column and perform aggregation for the minimum, mean and maximum values. Then reset the index and select the min, mean, max, engine and manufacture columns to return. Rename the aggregation columns to match the SQL result.\n\n::: {#29bcc0f1 .cell execution_count=19}\n``` {.python .cell-code}\n# SQL result\ntask5_sql = pd.read_sql_query(\"\"\"SELECT MIN(year), AVG(year), MAX(year), engine, manufacturer\n    FROM planes GROUP BY engine, manufacturer\"\"\", conn)\n\n# Pandas result with timing\nt5_st = timeit.default_timer()\n\ntask5_my = planes.groupby([\"engine\", \"manufacturer\"]).year.agg(\n    [\"min\", \"mean\", \"max\"]).reset_index()[[\"min\", \"mean\", \"max\", \"engine\", \"manufacturer\"]].rename(\n    columns={\"min\": \"MIN(year)\", \"mean\": \"AVG(year)\", \"max\": \"MAX(year)\"})\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task5_my.head(), \"\\n\")\n\nt5_et = timeit.default_timer()\nt5_dur = t5_et - t5_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task5_sql, task5_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n   MIN(year)  AVG(year)  MAX(year)         engine           manufacturer\n0     1975.0     1975.0     1975.0        4 Cycle                 CESSNA\n1        NaN        NaN        NaN        4 Cycle            JOHN G HESS\n2        NaN        NaN        NaN  Reciprocating  AMERICAN AIRCRAFT INC\n3     2007.0     2007.0     2007.0  Reciprocating     AVIAT AIRCRAFT INC\n4        NaN        NaN        NaN  Reciprocating          BARKER JACK L \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#5e7763aa .cell execution_count=20}\n``` {.python .cell-code}\n# Polars result with timing\nt5_st_pl = timeit.default_timer()\n\ntask5_pl = planes_pl.group_by([\"engine\", \"manufacturer\"]).agg(\n    [pl.col(\"year\").min().alias(\"MIN(year)\"), pl.col(\"year\").mean().alias(\"AVG(year)\"),\n    pl.col(\"year\").max().alias(\"MAX(year)\")]).select([\"MIN(year)\", \"AVG(year)\", \"MAX(year)\", \"engine\", \"manufacturer\"])\n\nt5_et_pl = timeit.default_timer()\nt5_dur_pl = t5_et_pl - t5_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task5_my.sort_values(by=[\"engine\", \"manufacturer\"]).reset_index(drop=True),\n                        task5_pl.to_pandas().sort_values(by=[\"engine\", \"manufacturer\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t5_dur, t5_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.003621  0.006494\nRelative to Pandas:  1           1.79\n```\n:::\n:::\n\n\n\n### Task 6\nThis SQL query selects rows from the planes table where the speed column does not have a null value.\n\nMy pandas command:\n - Creates a logical vector for slicing by checking if the speed column in the planes dataframe is not Null. This slice is used with the planes dataframe to select those rows where the speed was not Null. Finally, the index is reset.\n\n::: {#77fbcd1a .cell execution_count=21}\n``` {.python .cell-code}\n# SQL result\ntask6_sql = pd.read_sql_query(\"\"\"SELECT * FROM planes WHERE speed IS NOT NULL\"\"\", conn)\n\n# Pandas result with timing\nt6_st = timeit.default_timer()\n\ntask6_my = planes[planes[\"speed\"].notnull()].reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task6_my.head(), \"\\n\")\n\nt6_et = timeit.default_timer()\nt6_dur = t6_et - t6_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task6_sql, task6_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n  tailnum    year                      type manufacturer      model  engines  \\\n0  N201AA  1959.0  Fixed wing single engine       CESSNA        150        1   \n1  N202AA  1980.0   Fixed wing multi engine       CESSNA       421C        2   \n2  N350AA  1980.0   Fixed wing multi engine        PIPER  PA-31-350        2   \n3  N364AA  1973.0   Fixed wing multi engine       CESSNA       310Q        2   \n4  N378AA  1963.0  Fixed wing single engine       CESSNA       172E        1   \n\n   seats  speed         engine  \n0      2   90.0  Reciprocating  \n1      8   90.0  Reciprocating  \n2      8  162.0  Reciprocating  \n3      6  167.0  Reciprocating  \n4      4  105.0  Reciprocating   \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#7054267b .cell execution_count=22}\n``` {.python .cell-code}\n# Polars result with timing\nt6_st_pl = timeit.default_timer()\n\ntask6_pl = planes_pl.filter(pl.col(\"speed\").is_not_null()).sort(by=[])\n\nt6_et_pl = timeit.default_timer()\nt6_dur_pl = t6_et_pl - t6_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task6_my.sort_values(by=[\"speed\"]).reset_index(drop=True),\n                        task6_pl.to_pandas().sort_values(by=[\"speed\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t6_dur, t6_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001803  0.0008909\nRelative to Pandas:  1           0.494\n```\n:::\n:::\n\n\n\n### Task 7\n\nThis SQL query selects rows from the tailnum column in the planes table with a number of seats between 150 and 210 and a year greater than or equal to 2011.\n\nMy pandas command\n - Create a logical vector for slicing by checking rows in the seats column in the planes dataframe where the value is between 150 and 210, and checking rows where the year column in the planes dataframe has a value equal to or greater than 2011. This logical vector is then used to slice the planes data frame. Then only the tailnum column is returned, and the index is reset.\n\n::: {#459ef16d .cell execution_count=23}\n``` {.python .cell-code}\n# SQL result\ntask7_sql = pd.read_sql_query(\"\"\"SELECT tailnum FROM planes WHERE seats BETWEEN 150 AND 210 AND year >= 2011\"\"\", conn)\n\n# Pandas result with timing\nt7_st = timeit.default_timer()\n\ntask7_my = planes[(planes[\"seats\"].between(150,210) & (planes[\"year\"] >= 2011))][[\"tailnum\"]].reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task7_my.head(), \"\\n\")\n\nt7_et = timeit.default_timer()\nt7_dur = t7_et - t7_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task7_sql, task7_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n  tailnum\n0  N150UW\n1  N151UW\n2  N152UW\n3  N153UW\n4  N154UW \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#78b8e9a9 .cell execution_count=24}\n``` {.python .cell-code}\n# Polars result with timing\nt7_st_pl = timeit.default_timer()\n\ntask7_pl = planes_pl.filter((pl.col(\"seats\").is_between(150,210)) &\n                            (pl.col(\"year\") >= 2011)).select([\"tailnum\"]).sort(by=[])\n\nt7_et_pl = timeit.default_timer()\nt7_dur_pl = t7_et_pl - t7_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task7_my.sort_values(by=[\"tailnum\"]).reset_index(drop=True),\n                        task7_pl.to_pandas().sort_values(by=[\"tailnum\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t7_dur, t7_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001393  0.001259\nRelative to Pandas:  1           0.904\n```\n:::\n:::\n\n\n\n### Task 8\n\nThis SQL query selects rows from the tailnum, manufacturer, and seats columns in the planes table where the manufacturer is one of 'BOEING', 'AIRBUS', or 'EMBRAER' and the number of seats is greater than 390.\n\nMy pandas command:\n - Create a logical vector for slicing by checking rows in the manufacturer column in the planes dataframe where the value is one of 'BOEING', 'AIRBUS', 'EMBRAER' and checking rows in the seats column in the planes dataframe where the capacity is greater than 390. This logical vector is then used to slice the planes data frame. Then the tailnum, manufacturer and seats columns are returned, and the index is reset.\n\n::: {#3b7745c9 .cell execution_count=25}\n``` {.python .cell-code}\n# SQL result\ntask8_sql = pd.read_sql_query(\"\"\"SELECT tailnum, manufacturer, seats FROM planes\n    WHERE manufacturer IN ('BOEING', 'AIRBUS', 'EMBRAER') AND seats>390\"\"\", conn)\n\n# Pandas result with timing\nt8_st = timeit.default_timer()\n\ntask8_my = planes[(planes[\"manufacturer\"].isin([\"BOEING\", \"AIRBUS\", \"EMBRAER\"])) & \n           (planes[\"seats\"] > 390)][[\"tailnum\", \"manufacturer\", \"seats\"]].reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task8_my.head(), \"\\n\")\n\nt8_et = timeit.default_timer()\nt8_dur = t8_et - t8_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task8_sql, task8_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n  tailnum manufacturer  seats\n0  N206UA       BOEING    400\n1  N228UA       BOEING    400\n2  N272AT       BOEING    400\n3  N57016       BOEING    400\n4  N670US       BOEING    450 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#01c96108 .cell execution_count=26}\n``` {.python .cell-code}\n# Polars result with timing\nt8_st_pl = timeit.default_timer()\n\ntask8_pl = planes_pl.filter((pl.col(\"manufacturer\").is_in([\"BOEING\", \"AIRBUS\", \"EMBRAER\"])) &\n                            (pl.col(\"seats\") > 390)).select([\"tailnum\", \"manufacturer\", \"seats\"]).sort(by=[])\n\nt8_et_pl = timeit.default_timer()\nt8_dur_pl = t8_et_pl - t8_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task8_my.reset_index(drop=True),\n                        task8_pl.to_pandas().reset_index(drop=True), name=\"Polars\")\n\nprint_execution_data(t8_dur, t8_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001728  0.001018\nRelative to Pandas:  1           0.589\n```\n:::\n:::\n\n\n\n### Task 9\n\nThis SQL query selects unique rows from the year and seats columns in the planes table where the year is greater than or equal to 2012. The returned data is sorted in ascending order by year and descending order by seats.\n\nMy pandas command:\n - Create a logical vector for slicing by checking rows in the year column in the planes dataframe where the value is greater than or equal to 2012.  This logical vector is then used to slice the planes data frame. Drop duplicates corresponding to the year and seat columns in the resulting data frame. Then select the year and seats columns. Sort the dataframe by year in ascending order, followed by seats in descending order, and reset the index.\n\n::: {#e95b37d8 .cell execution_count=27}\n``` {.python .cell-code}\n# SQL result\ntask9_sql = pd.read_sql_query(\"\"\"SELECT DISTINCT year, seats FROM planes \n    WHERE year >= 2012 ORDER BY year ASC, seats DESC\"\"\", conn)\n\n# Pandas result with timing\nt9_st = timeit.default_timer()\n\ntask9_my = planes[(planes[\"year\"] >= 2012)].drop_duplicates(\n    subset=[\"year\", \"seats\"])[[\"year\", \"seats\"]].sort_values(\n    by=[\"year\", \"seats\"], ascending=[True, False]).reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task9_my.head(), \"\\n\")\n\nt9_et = timeit.default_timer()\nt9_dur = t9_et - t9_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task9_sql, task9_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n     year  seats\n0  2012.0    379\n1  2012.0    377\n2  2012.0    260\n3  2012.0    222\n4  2012.0    200 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#84a591bb .cell execution_count=28}\n``` {.python .cell-code}\n# Polars result with timing\nt9_st_pl = timeit.default_timer()\n\ntask9_pl = planes_pl.filter(pl.col(\"year\") >= 2012).unique(\n    subset=[\"year\", \"seats\"]).select([\"year\", \"seats\"]).sort(by=[\"year\",\"seats\"], descending=[False, True])\nt9_et_pl = timeit.default_timer()\n\nt9_dur_pl = t9_et_pl - t9_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task9_my.reset_index(drop=True),\n                        task9_pl.to_pandas().reset_index(drop=True), name=\"Polars\")\n\nprint_execution_data(t9_dur, t9_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.002258  0.003938\nRelative to Pandas:  1           1.74\n```\n:::\n:::\n\n\n\n### Task 10\n\nThis SQL query selects unique rows from the year and seats columns in the planes table where the year is greater than or equal to 2012. The returned data is sorted in descending order by seats, then ascending order by year.\n\nMy pandas command:\n - Create a logical vector for slicing by checking rows in the year column in the planes dataframe where the value is greater than or equal to 2012. This logical vector is then used to slice the planes dataframe. In the resulting dataframe, drop duplicates corresponding to the year and seats columns. Then select the year and seats columns. Then sort the dataframe by seats in descending order, followed by year in ascending order, and reset the index.\n\n::: {#63e77152 .cell execution_count=29}\n``` {.python .cell-code}\n# SQL result\ntask10_sql = pd.read_sql_query(\"\"\"SELECT DISTINCT year, seats FROM planes WHERE year >= 2012 ORDER BY seats DESC, year ASC\"\"\", conn)\n\n# Pandas result with timing\nt10_st = timeit.default_timer()\n\ntask10_my = planes[(planes['year'] >= 2012)].drop_duplicates(\n    subset=[\"year\", \"seats\"])[[\"year\", \"seats\"]].sort_values(\n    by=[\"seats\", \"year\"], ascending= [False,True]).reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task10_my.head(), \"\\n\")\n\nt10_et = timeit.default_timer()\nt10_dur = t10_et - t10_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task10_sql, task10_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n     year  seats\n0  2012.0    379\n1  2013.0    379\n2  2012.0    377\n3  2013.0    377\n4  2012.0    260 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#8f6559f4 .cell execution_count=30}\n``` {.python .cell-code}\n# Polars result with timing\nt10_st_pl = timeit.default_timer()\n\ntask10_pl = planes_pl.filter(pl.col(\"year\") >= 2012).unique(\n    subset=[\"year\", \"seats\"]).select([\"year\", \"seats\"]).sort(by=[\"seats\", \"year\"], descending=[True, False])\n\nt10_et_pl = timeit.default_timer()\nt10_dur_pl = t10_et_pl - t10_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task10_my.reset_index(drop=True),\n                        task10_pl.to_pandas().reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t10_dur, t10_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.002203  0.003303\nRelative to Pandas:  1           1.5\n```\n:::\n:::\n\n\n\n### Task 11\n\nThis SQL query counts the number of planes with the number of seats above 200 and groups them by manufacturer. Showing how many planes each manufacturer has where the seats are greater than 200.\n\nMy pandas command\n - Create a logical vector for slicing by checking rows in the seats column in the planes dataframe where the value is greater than 200. This logical vector is then used to slice the planes dataframe. The resulting dataframe is then grouped by the manufacturer, and the size of each group is evaluated. I reset the index at the same time as renaming the count column to COUNT(*).\n\n::: {#9a47b23d .cell execution_count=31}\n``` {.python .cell-code}\n# SQL result\ntask11_sql = pd.read_sql_query(\"\"\"SELECT manufacturer, COUNT(*) FROM planes \n    WHERE seats > 200 GROUP BY manufacturer\"\"\", conn)\n\n# Pandas result with timing\nt11_st = timeit.default_timer()\n\ntask11_my = planes[(planes[\"seats\"] > 200)].groupby(\"manufacturer\").size().reset_index(name=\"COUNT(*)\")\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task11_my.head(), \"\\n\")\n\nt11_et = timeit.default_timer()\nt11_dur = t11_et - t11_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task11_sql, task11_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n       manufacturer  COUNT(*)\n0            AIRBUS        66\n1  AIRBUS INDUSTRIE         4\n2            BOEING       225 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#81cfbb1a .cell execution_count=32}\n``` {.python .cell-code}\n# Polars result with timing\nt11_st_pl = timeit.default_timer()\n\ntask11_pl = planes_pl.filter(pl.col(\"seats\") > 200).group_by(\"manufacturer\").agg(\n    pl.len().alias(\"COUNT(*)\"))\n\nt11_et_pl = timeit.default_timer()\nt11_dur_pl = t11_et_pl - t11_st_pl\n\n# Polars returns uint32 for len(), so we need to cast to allow comparison with pandas.\ntask11_pl = task11_pl.with_columns(pl.col(\"COUNT(*)\").cast(pl.Int64))\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task11_my.sort_values(by=[\"manufacturer\", \"COUNT(*)\"]).reset_index(drop=True),\n                        task11_pl.to_pandas().sort_values(by=[\"manufacturer\", \"COUNT(*)\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t11_dur, t11_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001559  0.001686\nRelative to Pandas:  1           1.08\n```\n:::\n:::\n\n\n\n### Task 12\n\nThis SQL query counts the number of planes for each manufacturer and selects those manufacturers with more than 10 planes. The manufacture and count are returned.\n\nMy pandas command:\n - Group the rows of the planes dataframe by the manufacturer and retrieve the size of each group. Reset the index and rename the index column to count. Use the query function to return only those rows where the count is greater than 10. Rename the count column to COUNT(*) and reset the index.\n\n::: {#cfa9db29 .cell execution_count=33}\n``` {.python .cell-code}\n# SQL result\ntask12_sql = pd.read_sql_query(\"\"\"SELECT manufacturer, COUNT(*) FROM planes \nGROUP BY manufacturer HAVING COUNT(*) > 10\"\"\", conn)\n\n# Pandas result with timing\nt12_st = timeit.default_timer()\n\ntask12_my = planes.groupby(\"manufacturer\").size().reset_index(name=\"count\").query(\n    \"count > 10\").rename(columns={\"count\": \"COUNT(*)\"}).reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task12_my.head(), \"\\n\")\n\nt12_et = timeit.default_timer()\nt12_dur = t12_et - t12_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task12_sql, task12_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n       manufacturer  COUNT(*)\n0            AIRBUS       336\n1  AIRBUS INDUSTRIE       400\n2            BOEING      1630\n3    BOMBARDIER INC       368\n4           EMBRAER       299 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#55e691b0 .cell execution_count=34}\n``` {.python .cell-code}\n# Polars result with timing\nt12_st_pl = timeit.default_timer()\n\ntask12_pl = planes_pl.group_by(\"manufacturer\").agg(pl.len().alias(\"COUNT(*)\")).filter(\n    pl.col(\"COUNT(*)\") > 10)\n\nt12_et_pl = timeit.default_timer()\nt12_dur_pl = t12_et_pl - t12_st_pl\n\n# Polars returns uint32 for len(), so we need to cast to allow comparison with pandas.\ntask12_pl = task12_pl.with_columns(pl.col(\"COUNT(*)\").cast(pl.Int64))\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task12_my.sort_values(by=[\"manufacturer\", \"COUNT(*)\"]).reset_index(drop=True),\n                        task12_pl.to_pandas().sort_values(by=[\"manufacturer\", \"COUNT(*)\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t12_dur, t12_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.002903  0.004606\nRelative to Pandas:  1           1.59\n```\n:::\n:::\n\n\n\n### Task 13\n\nThis SQL query will show the number of manufacturers that have more than 10 planes with a seat capacity greater than 200.\n\nMy pandas command:\n - Create a logical vector for slicing by checking rows in the seats column in the planes dataframe where the value is greater than 200. Slice the planes dataframe using this logical vector, then group the rows by the manufacturer column. Retrieve the size of each group. Reset the index and rename the index column to count. Use the query function to return only those rows where the count is greater than 10. Rename the count column to COUNT(*) and reset the index\n\n::: {#64a2d968 .cell execution_count=35}\n``` {.python .cell-code}\n# SQL result\ntask13_sql = pd.read_sql_query(\"\"\"SELECT manufacturer, COUNT(*) FROM planes \n    WHERE seats > 200 GROUP BY manufacturer HAVING COUNT(*) > 10\"\"\", conn)\n\n# Pandas result with timing\nt13_st = timeit.default_timer()\n\ntask13_my = planes[planes[\"seats\"] > 200].groupby(\"manufacturer\").size().reset_index(\n    name=\"count\").query(\"count >10\").rename(columns={\"count\": \"COUNT(*)\"}).reset_index(drop=True)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task13_my.head(), \"\\n\")\n\nt13_et = timeit.default_timer()\nt13_dur = t13_et - t13_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task13_sql, task13_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n  manufacturer  COUNT(*)\n0       AIRBUS        66\n1       BOEING       225 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#b1262fde .cell execution_count=36}\n``` {.python .cell-code}\n# Polars result with timing\nt13_st_pl = timeit.default_timer()\n\ntask13_pl = planes_pl.filter(pl.col(\"seats\") > 200).group_by(\"manufacturer\").agg(pl.len().alias(\"COUNT(*)\")).filter(\n    pl.col(\"COUNT(*)\") > 10)\n\nt13_et_pl = timeit.default_timer()\nt13_dur_pl = t13_et_pl - t13_st_pl\n\n# Polars returns uint32 for len(), so we need to cast to allow comparison with pandas.\ntask13_pl = task13_pl.with_columns(pl.col(\"COUNT(*)\").cast(pl.Int64))\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task13_my.sort_values(by=[\"manufacturer\", \"COUNT(*)\"]).reset_index(drop=True),\n                        task13_pl.to_pandas().sort_values(by=[\"manufacturer\", \"COUNT(*)\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t13_dur, t13_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.002486  0.00208\nRelative to Pandas:  1           0.837\n```\n:::\n:::\n\n\n\n### Task 14\n\nThis SQL query shows the top 10 manufacturers by the number of planes they have in the planes table.\n\nMy pandas command:\n - Group the rows in the planes dataframe by the manufacturer column. Retrieve the size of each group. Reset the index and rename the index column to howmany. Sort the dataframe by the howmany column in descending order. Reset the index and display the first 10 rows.\n\n::: {#da6d7a0c .cell execution_count=37}\n``` {.python .cell-code}\n# SQL result\ntask14_sql = pd.read_sql_query(\"\"\"SELECT manufacturer, COUNT(*) AS howmany FROM planes\n    GROUP BY manufacturer ORDER BY howmany DESC LIMIT 10\"\"\", conn)\n\n# Pandas result with timing\nt14_st = timeit.default_timer()\n\ntask14_my = planes.groupby(\"manufacturer\").size().reset_index(\n    name=\"howmany\").sort_values(by=\"howmany\", ascending=False).reset_index(drop=True).head(10)\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task14_my.head(), \"\\n\")\n\nt14_et = timeit.default_timer()\nt14_dur = t14_et - t14_st\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task14_sql, task14_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n       manufacturer  howmany\n0            BOEING     1630\n1  AIRBUS INDUSTRIE      400\n2    BOMBARDIER INC      368\n3            AIRBUS      336\n4           EMBRAER      299 \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#152bb75e .cell execution_count=38}\n``` {.python .cell-code}\n# Polars result with timing\nt14_st_pl = timeit.default_timer()\n\ntask14_pl = planes_pl.group_by(\"manufacturer\").agg(pl.len().alias(\"howmany\")).sort(\n    \"howmany\", descending=True).limit(10)\n\nt14_et_pl = timeit.default_timer()\nt14_dur_pl = t14_et_pl - t14_st_pl\n\n# Polars returns uint32 for len(), so we need to cast to allow comparison with pandas.\ntask14_pl = task14_pl.with_columns(pl.col(\"howmany\").cast(pl.Int64))\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task14_my.sort_values(by=[\"manufacturer\", \"howmany\"]).reset_index(drop=True),\n                        task14_pl.to_pandas().sort_values(by=[\"manufacturer\", \"howmany\"]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t14_dur, t14_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.001631  0.006682\nRelative to Pandas:  1           4.1\n```\n:::\n:::\n\n\n\n### Task 15\nThis SQL query  returns all rows and columns from the flights table and columns year, speed, and seats from the planes as plane_year, plane_speed, and plane_seat. Any row where the tailnum from flights matches the tailnum in planes the value from the year, speed and seats columns from planes will be added to those columns for that row in the output. If no matching tailnum is found in the planes table, then NULL is returned for the plane_year, plane_speed, and plane_seat for that row.\n\nMy pandas command:\n - Select the tailnum, year, speed, and seats columns from planes and assign them to temp15.\n - Perform a left merge of the flights and temp15 dataframes using tailnum column. Disable suffixes for flights and set to \\_p for the planes columns. This will prevent columns in both flights and planes from being renamed in flights with a suffix. The planes column will be added with the suffix \\_p. Finally, rename the year, speed, and seats columns with plane\\_ prefix.\n\n::: {#67cff78e .cell execution_count=39}\n``` {.python .cell-code}\n# SQL result\ntask15_sql = pd.read_sql_query(\"\"\"SELECT flights.*, planes.year AS plane_year, \n    planes.speed AS plane_speed, planes.seats AS plane_seats FROM flights\n    LEFT JOIN planes ON flights.tailnum=planes.tailnum\"\"\", conn)\n\n# Pandas result with timing\nt15_st = timeit.default_timer()\n\n# The following two lines could be done as one without using a temporary variable. However, it is easier to read this way.\ntemp15 = planes[[\"tailnum\", \"year\", \"speed\", \"seats\"]]\ntask15_my = pd.merge(flights, temp15,\n    on=\"tailnum\", how=\"left\", suffixes=(None, \"_p\")).rename(\n    columns={\"year_p\":\"plane_year\",\"speed\":\"plane_speed\", \"seats\":\"plane_seats\"})\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task15_my.head(), \"\\n\")\n\nt15_et = timeit.default_timer()\nt15_dur = t15_et - t15_st\n\n# Comparing the result from SQL and Pandas\n# This command will generate a future warning as seen below.\n# This can be resoled by ensuring all Null type (None, NA, NAN) are replaced with np.nan \nprint(\"This feature warning can be and has been disable in subsequent tasks by making the null like values consistent in the dataframes being compared.\")\ntest_dataframe_equality(task15_sql, task15_my)\n\n# Make null type values consistent\ntask15_sql.fillna(value=np.nan, inplace=True)\ntask15_my.fillna(value=np.nan, inplace=True)\n\n# Assert after making null type values consistent\npd.testing.assert_frame_equal(task15_sql, task15_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n   year  month  day  dep_time  sched_dep_time  dep_delay  arr_time  \\\n0  2013      1    1     517.0             515        2.0     830.0   \n1  2013      1    1     533.0             529        4.0     850.0   \n2  2013      1    1     542.0             540        2.0     923.0   \n3  2013      1    1     544.0             545       -1.0    1004.0   \n4  2013      1    1     554.0             600       -6.0     812.0   \n\n   sched_arr_time  arr_delay carrier  ...  origin dest air_time distance  \\\n0             819       11.0      UA  ...     EWR  IAH    227.0     1400   \n1             830       20.0      UA  ...     LGA  IAH    227.0     1416   \n2             850       33.0      AA  ...     JFK  MIA    160.0     1089   \n3            1022      -18.0      B6  ...     JFK  BQN    183.0     1576   \n4             837      -25.0      DL  ...     LGA  ATL    116.0      762   \n\n   hour  minute            time_hour  plane_year plane_speed  plane_seats  \n0     5      15  2013-01-01 05:00:00      1999.0         NaN        149.0  \n1     5      29  2013-01-01 05:00:00      1998.0         NaN        149.0  \n2     5      40  2013-01-01 05:00:00      1990.0         NaN        178.0  \n3     5      45  2013-01-01 05:00:00      2012.0         NaN        200.0  \n4     6       0  2013-01-01 06:00:00      1991.0         NaN        178.0  \n\n[5 rows x 22 columns] \n\nThis feature warning can be and has been disable in subsequent tasks by making the null like values consistent in the dataframes being compared.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nC:\\Users\\darrin\\AppData\\Local\\Temp\\ipykernel_21080\\4104427652.py:12: FutureWarning:\n\nMismatched null-like values None and nan found. In a future version, pandas equality-testing functions (e.g. assert_frame_equal) will consider these not-matching and raise.\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#14a57770 .cell execution_count=40}\n``` {.python .cell-code}\n# Polars result with timing\nt15_st_pl = timeit.default_timer()\n\n# The following two lines could be done as one without using a temporary variable. However, it is easier to read this way.\ntemp15_pl = planes_pl.select([\"tailnum\", \"year\", \"speed\", \"seats\"])\ntask15_pl = flights_pl.join(temp15_pl, on=[\"tailnum\"], how=\"left\").rename({\"year_right\":\"plane_year\",\"speed\":\"plane_speed\", \"seats\":\"plane_seats\"})\n\nt15_et_pl = timeit.default_timer()\nt15_dur_pl = t15_et_pl - t15_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\n# Make null types consistent\ntask15_pl_pd = task15_pl.to_pandas()\ntask15_pl_pd.fillna(value=np.nan, inplace=True)\ntest_dataframe_equality(task15_my.reset_index(drop=True),\n                        task15_pl_pd.reset_index(drop=True), name=\"Polars\")\n\nprint_execution_data(t15_dur, t15_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.239  0.01319\nRelative to Pandas:  1           0.0552\n```\n:::\n:::\n\n\n\n### Task 16\n\nThis SQL query returns a dataframe that includes all the columns from both planes and airlines, with only the unique carrier and tailnum combinations that exist in the flight dataframe. \n\nMy pandas command:\n- From the flights dataframe select the carrier and tailnum columns and drop duplicate rows. Join the result of the previous step with the planes dataframe on the tailnum column using an inner join and assign to temp16. Then join temp16 with the airlines dataframe on the carrier column using an inner join.\n\n::: {#ce023081 .cell execution_count=41}\n``` {.python .cell-code}\n# SQL result\ntask16_sql = pd.read_sql_query(\"\"\"SELECT planes.*, airlines.* \nFROM (SELECT DISTINCT carrier, tailnum FROM flights) AS cartail\nINNER JOIN planes ON cartail.tailnum=planes.tailnum\nINNER JOIN airlines ON cartail.carrier=airlines.carrier\"\"\", conn)\n\n# Sort needed for comparison with pandas result\ntask16_sql = task16_sql.sort_values(by=[\"tailnum\", \"carrier\"], ascending=[True, True]).reset_index(drop=True)\n\n# Pandas result with timing\nt16_st = timeit.default_timer()\n\n# The following two lines could be done as one without using a temporary variable. However, it is easier to read this way.\ntemp16 = pd.merge(flights[[\"carrier\", \"tailnum\"]].drop_duplicates(), planes, on=\"tailnum\", how=\"inner\")\ntask16_my = pd.merge(temp16, airlines, on=\"carrier\", how=\"inner\")\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task16_my.head(), \"\\n\")\n\nt16_et = timeit.default_timer()\nt16_dur = t16_et - t16_st\n\n# Create a copy to use with polars comparison\ntask16_pd= task16_my.copy()\n\n# Move the carrier column and sort for comparison with SQL result \ntask16_my.insert(9, \"carrier\", task16_my.pop(\"carrier\"))\ntask16_my=task16_my.sort_values(by=[\"tailnum\",\"carrier\"], ascending=[True, True]).reset_index(drop=True)\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task16_sql, task16_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n  carrier tailnum    year                     type manufacturer     model  \\\n0      UA  N14228  1999.0  Fixed wing multi engine       BOEING   737-824   \n1      UA  N24211  1998.0  Fixed wing multi engine       BOEING   737-824   \n2      AA  N619AA  1990.0  Fixed wing multi engine       BOEING   757-223   \n3      B6  N804JB  2012.0  Fixed wing multi engine       AIRBUS  A320-232   \n4      DL  N668DN  1991.0  Fixed wing multi engine       BOEING   757-232   \n\n   engines  seats  speed     engine                    name  \n0        2    149    NaN  Turbo-fan   United Air Lines Inc.  \n1        2    149    NaN  Turbo-fan   United Air Lines Inc.  \n2        2    178    NaN  Turbo-fan  American Airlines Inc.  \n3        2    200    NaN  Turbo-fan         JetBlue Airways  \n4        2    178    NaN  Turbo-fan    Delta Air Lines Inc.   \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#cf3fb2d1 .cell execution_count=42}\n``` {.python .cell-code}\n# Polars result with timing\nt16_st_pl = timeit.default_timer()\n\n# The following two lines could be done as one without using a temporary variable. However, it is easier to read this way.\ntemp16_pl = flights_pl.select([\"carrier\", \"tailnum\"]).unique().join(planes_pl, on=[\"tailnum\"], how=\"inner\")\ntask16_pl = temp16_pl.join(airlines_pl, on=[\"carrier\"], how=\"inner\")\n\nt16_et_pl = timeit.default_timer()\nt16_dur_pl = t16_et_pl - t16_st_pl\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task16_pd.sort_values(by=[\"tailnum\",\"carrier\"], ascending=[True, True]).reset_index(drop=True),\n                        task16_pl.to_pandas().sort_values(by=[\"tailnum\",\"carrier\"], ascending=[True, True]).reset_index(drop=True),\n                        name=\"Polars\")\n\nprint_execution_data(t16_dur, t16_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.1513  0.02181\nRelative to Pandas:  1           0.144\n```\n:::\n:::\n\n\n\n### Task 17\n\nThis SQL query retrieves flight data originating from EWR and joins it with averaged daily weather from the same location.\n\nMy pandas command:\n- From the flights dataframe only select rows where the origin column equals 'EWR' and assign the result to flights2\n- From the weather dataframe, select only rows where the origin column equal 'EWR'. Then group rows by the year, month, and day. Perform averaging on the temp and humidity columns. In the resulting dataframe, rename the temp and humidity columns to atemp and ahumid. Reset the dataframe index and assign the result to weather2. \n- Merge the weather2 into the flights2 dataframe from the left on the year, month and days columns. A left merge will result in all the rows of flights2 being copied into the result. If there is no matching atemp or ahumid for any rows in flights2, then Nan will be inserted into these columns for the rows.\n\n::: {#3b8a5b48 .cell execution_count=43}\n``` {.python .cell-code}\n# SQL query\ntask17_sql = pd.read_sql_query(\"\"\"SELECT flights2.*, atemp, ahumid FROM ( SELECT * FROM flights WHERE origin='EWR') AS flights2\nLEFT JOIN (\nSELECT year, month, day, AVG(temp) AS atemp, AVG(humid) AS ahumid FROM weather WHERE origin='EWR' GROUP BY year, month, day\n) AS weather2\nON flights2.year=weather2.year\nAND flights2.month=weather2.month\nAND flights2.day=weather2.day\"\"\", conn)\n\n# Pandas result with timing\nt17_st = timeit.default_timer()\n# From the flights dataframe, select only rows where the origin column equals EWR and assign the result to flights2 \nflights2 = flights[(flights.origin=='EWR')]\n\n# From the weather dataframe, select only rows where the origin column equals EWR. Then group rows by year, month and day. Perform averaging on the temp and humidity columns.\n# Rename the temp and humidity columns in the resulting data frame as atemp and ahumid. Reset the dataframe index and assign the result to weather2.\nweather2 = weather[weather.origin==\"EWR\"].groupby([\"year\",\"month\",\"day\"])[[\"temp\",\"humid\"]].mean(numeric_only=True).rename(columns={'temp':'atemp','humid':'ahumid'}).reset_index()\n\n# Merge the weather2 dataframe into the flights2 dataframe from the left on the year, month and days columns. Left merge will result in all the rows of flights2 will be in the result.\n# If there is no matching atemp or ahumid for any rows in flights2, then a NaN will be inserted into the columns for those rows.\ntask17_my = pd.merge(flights2, weather2, on=['year', 'month', 'day'], how='left')\n\nprint(\"Head of the Pandas data frame resulting from the query:\")\nprint(task17_my.head(), \"\\n\")\n\nt17_et = timeit.default_timer()\nt17_dur = t17_et - t17_st\n\n# Make null type values consistent - see Task 15 for description\ntask17_sql.fillna(value=np.nan, inplace=True)\ntask17_my.fillna(value=np.nan, inplace=True)\n\n# Comparing the result from SQL and Pandas\ntest_dataframe_equality(task17_sql, task17_my)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHead of the Pandas data frame resulting from the query:\n   year  month  day  dep_time  sched_dep_time  dep_delay  arr_time  \\\n0  2013      1    1     517.0             515        2.0     830.0   \n1  2013      1    1     554.0             558       -4.0     740.0   \n2  2013      1    1     555.0             600       -5.0     913.0   \n3  2013      1    1     558.0             600       -2.0     923.0   \n4  2013      1    1     559.0             600       -1.0     854.0   \n\n   sched_arr_time  arr_delay carrier  ...  tailnum origin dest air_time  \\\n0             819       11.0      UA  ...   N14228    EWR  IAH    227.0   \n1             728       12.0      UA  ...   N39463    EWR  ORD    150.0   \n2             854       19.0      B6  ...   N516JB    EWR  FLL    158.0   \n3             937      -14.0      UA  ...   N53441    EWR  SFO    361.0   \n4             902       -8.0      UA  ...   N76515    EWR  LAS    337.0   \n\n   distance  hour  minute            time_hour  atemp     ahumid  \n0      1400     5      15  2013-01-01 05:00:00  38.48  58.386087  \n1       719     5      58  2013-01-01 05:00:00  38.48  58.386087  \n2      1065     6       0  2013-01-01 06:00:00  38.48  58.386087  \n3      2565     6       0  2013-01-01 06:00:00  38.48  58.386087  \n4      2227     6       0  2013-01-01 06:00:00  38.48  58.386087  \n\n[5 rows x 21 columns] \n\nOutcome of comparison: SQL and Pandas results are equal\n```\n:::\n:::\n\n\n\n::: {#ef15e230 .cell execution_count=44}\n``` {.python .cell-code}\n# Polars result with timing\nt17_st_pl = timeit.default_timer()\n\nflights2_pl = flights_pl.filter(pl.col(\"origin\") == \"EWR\")\nweather2_pl = (weather_pl.filter(pl.col(\"origin\") == \"EWR\").group_by([\"year\", \"month\", \"day\"]).agg([pl.col(\"temp\").mean().alias(\"atemp\"),\n                pl.col(\"humid\").mean().alias(\"ahumid\")]))\ntask17_pl=flights2_pl.join(weather2_pl, on=[\"year\", \"month\", \"day\"], how=\"left\")\n\nt17_et_pl = timeit.default_timer()\nt17_dur_pl = t17_et_pl - t17_st_pl\n\n# Make null type values consistent - see Task 15 for description\ntask17_pl_pd = task17_pl.to_pandas()\ntask17_pl_pd.fillna(value=np.nan, inplace=True)\n\n# Checking the Pandas result == Polars result. We need to convert the polars dataframe to a pandas dataframe,\n# sort and reset the index for the comparison\ntest_dataframe_equality(task17_my, task17_pl_pd, name=\"Polars\")\n\nprint_execution_data(t17_dur, t17_dur_pl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOutcome of comparison: Polars and Pandas results are equal\n\nMetric                Pandas    Polars\nExecution time [s]:  0.1417  0.01958\nRelative to Pandas:  1           0.138\n```\n:::\n:::\n\n\n\n::: {#35962471 .cell execution_count=45}\n``` {.python .cell-code}\n# Close database connection\nconn.close()\n```\n:::\n\n\n## Summary\nThis Jupyter Notebook demonstrates the use of `pandas` and `polars` for performing equivalent SQL queries. For cases where the queries were simple, the pandas queries were faster (up to 2x) than polars. However, for cases where the queries were complex, such as the joins, polars was faster (up tp 11x) than pandas.\n\n",
    "supporting": [
      "Task_6D_files"
    ],
    "filters": [],
    "includes": {}
  }
}